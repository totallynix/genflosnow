<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Mini Metro-ish</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        padding: 0;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        background: #111215;
        color: #111827;
        height: 100vh;
        display: flex;
        flex-direction: column;
      }
      header {
        padding: 8px 16px;
        font-size: 14px;
        border-bottom: 1px solid #1f2937;
        display: flex;
        justify-content: space-between;
        align-items: center;
        color: #e5e7eb;
      }
      header a {
        color: #9ca3af;
        text-decoration: none;
        font-size: 13px;
      }
      header a:hover {
        text-decoration: underline;
      }
      #canvas-wrapper {
        flex: 1;
        position: relative;
        background: #f4f4ec; /* light map-like background */
      }
      #metro-canvas {
        width: 100%;
        height: 100%;
        display: block;
      }
      #hud {
        position: absolute;
        top: 8px;
        left: 8px;
        font-size: 12px;
        color: #374151;
        background: rgba(244, 244, 236, 0.8);
        padding: 4px 8px;
        border-radius: 6px;
      }
      #hint {
        position: absolute;
        left: 8px;
        bottom: 8px;
        font-size: 12px;
        color: #374151;
        background: rgba(244, 244, 236, 0.8);
        padding: 6px 8px;
        border-radius: 6px;
      }
    </style>
  </head>
  <body>
    <header>
      <div>Mini Metro-ish prototype</div>
      <div><a href="/">Back to GAHOOT</a></div>
    </header>

    <div id="canvas-wrapper">
      <canvas id="metro-canvas"></canvas>
      <div id="hud">
        Lines: <span id="hud-lines">0</span> Â· Stations:
        <span id="hud-stations">0</span>
      </div>
      <div id="hint">
        Click to add stations. Drag from one station to another to draw a line.
      </div>
    </div>

    <script>
      const canvas = document.getElementById("metro-canvas");
      const ctx = canvas.getContext("2d");

      const hudLines = document.getElementById("hud-lines");
      const hudStations = document.getElementById("hud-stations");

      function resizeCanvas() {
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
        draw();
      }

      window.addEventListener("resize", resizeCanvas);
      // Ensure layout is ready
      window.addEventListener("load", resizeCanvas);

      const stations = []; // { x, y, shape }
      const lines = []; // { color, points: [ {x,y}, ... ] }

      const shapes = ["circle", "square", "triangle"];
      const lineColors = ["#e74c3c", "#3498db", "#2ecc71", "#f1c40f", "#9b59b6"];

      let currentLine = null;
      let draggingFromStation = null;

      function drawStation(s) {
        ctx.save();
        ctx.translate(s.x, s.y);
        ctx.lineWidth = 3;
        ctx.strokeStyle = "#111827";
        ctx.fillStyle = "#f9fafb";

        if (s.shape === "circle") {
          ctx.beginPath();
          ctx.arc(0, 0, 10, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
        } else if (s.shape === "square") {
          ctx.beginPath();
          ctx.rect(-10, -10, 20, 20);
          ctx.fill();
          ctx.stroke();
        } else if (s.shape === "triangle") {
          ctx.beginPath();
          ctx.moveTo(0, -12);
          ctx.lineTo(12, 10);
          ctx.lineTo(-12, 10);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
        }

        ctx.restore();
      }

      function drawLine(line) {
        if (line.points.length < 2) return;
        ctx.save();
        ctx.strokeStyle = line.color;
        ctx.lineWidth = 6;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.beginPath();
        ctx.moveTo(line.points[0].x, line.points[0].y);
        for (let i = 1; i < line.points.length; i++) {
          ctx.lineTo(line.points[i].x, line.points[i].y);
        }
        ctx.stroke();
        ctx.restore();
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const rect = canvas.getBoundingClientRect();
        ctx.save();
        ctx.strokeStyle = "#e5e5dc";
        ctx.lineWidth = 1;
        const step = 40;
        for (let x = 0; x < rect.width; x += step) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, rect.height);
          ctx.stroke();
        }
        for (let y = 0; y < rect.height; y += step) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(rect.width, y);
          ctx.stroke();
        }
        ctx.restore();

        for (const line of lines) {
          drawLine(line);
        }
        if (currentLine && currentLine.points.length >= 2) {
          drawLine(currentLine);
        }

        for (const s of stations) {
          drawStation(s);
        }

        hudLines.textContent = lines.length;
        hudStations.textContent = stations.length;
      }

      function getMousePos(e) {
        const rect = canvas.getBoundingClientRect();
        return {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top,
        };
      }

      function findStationAt(pos, radius = 18) {
        for (const s of stations) {
          const dx = s.x - pos.x;
          const dy = s.y - pos.y;
          if (Math.sqrt(dx * dx + dy * dy) <= radius) return s;
        }
        return null;
      }

      canvas.addEventListener("click", (e) => {
        // ignore click if we just finished a drag
        if (draggingFromStation || currentLine) return;

        const pos = getMousePos(e);
        const existing = findStationAt(pos);
        if (existing) return;

        const shape = shapes[stations.length % shapes.length];
        stations.push({ x: pos.x, y: pos.y, shape });
        draw();
      });

      canvas.addEventListener("mousedown", (e) => {
        const pos = getMousePos(e);
        const s = findStationAt(pos);
        if (!s) return;

        draggingFromStation = s;
        currentLine = {
          color: lineColors[lines.length % lineColors.length],
          points: [{ x: s.x, y: s.y }, { x: pos.x, y: pos.y }],
        };
      });

      canvas.addEventListener("mousemove", (e) => {
        if (!currentLine) return;
        const pos = getMousePos(e);
        currentLine.points[currentLine.points.length - 1] = pos;
        draw();
      });

      canvas.addEventListener("mouseup", (e) => {
        if (!currentLine || !draggingFromStation) return;
        const pos = getMousePos(e);
        const target = findStationAt(pos);

        if (target && target !== draggingFromStation) {
          currentLine.points[currentLine.points.length - 1] = {
            x: target.x,
            y: target.y,
          };
          lines.push(currentLine);
        }

        currentLine = null;
        draggingFromStation = null;
        draw();
      });

      canvas.addEventListener("mouseleave", () => {
        currentLine = null;
        draggingFromStation = null;
        draw();
      });
    </script>
  </body>
</html>
