<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Mini Metro-ish</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      body {
        margin: 0;
        padding: 0;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        background: #050816;
        color: #e5e7eb;
        height: 100vh;
        display: flex;
        flex-direction: column;
      }
      header {
        padding: 8px 16px;
        font-size: 14px;
        border-bottom: 1px solid #111827;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      header a {
        color: #9ca3af;
        text-decoration: none;
        font-size: 13px;
      }
      header a:hover {
        text-decoration: underline;
      }
      #canvas-wrapper {
        flex: 1;
        position: relative;
      }
      #metro-canvas {
        width: 100%;
        height: 100%;
        display: block;
        background: #020617;
      }
      #hint {
        position: absolute;
        left: 12px;
        bottom: 12px;
        font-size: 12px;
        color: #9ca3af;
        background: rgba(15, 23, 42, 0.9);
        padding: 6px 8px;
        border-radius: 6px;
      }
    </style>
  </head>
  <body>
    <header>
      <div>Mini Metro-ish prototype</div>
      <div><a href="/">Back to GAHOOT</a></div>
    </header>

    <div id="canvas-wrapper">
      <canvas id="metro-canvas"></canvas>
      <div id="hint">
        Click to add stations. Drag between stations to draw lines.
      </div>
    </div>

    <script>
      const canvas = document.getElementById("metro-canvas");
      const ctx = canvas.getContext("2d");

      function resizeCanvas() {
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * window.devicePixelRatio;
        canvas.height = rect.height * window.devicePixelRatio;
        ctx.setTransform(window.devicePixelRatio, 0, 0, window.devicePixelRatio, 0, 0);
        draw();
      }

      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();

      const stations = []; // { x, y, shape }
      const lines = [];    // { color, points: [ {x,y}, ... ] }

      const shapes = ["circle", "square", "triangle"];
      const lineColors = ["#ef4444", "#2563eb", "#eab308", "#16a34a"];

      let currentLine = null;
      let draggingFromStation = null;

      function drawStation(s) {
        ctx.save();
        ctx.translate(s.x, s.y);
        ctx.lineWidth = 3;
        ctx.strokeStyle = "#f9fafb";

        if (s.shape === "circle") {
          ctx.beginPath();
          ctx.arc(0, 0, 10, 0, Math.PI * 2);
          ctx.stroke();
        } else if (s.shape === "square") {
          ctx.strokeRect(-10, -10, 20, 20);
        } else if (s.shape === "triangle") {
          ctx.beginPath();
          ctx.moveTo(0, -12);
          ctx.lineTo(12, 10);
          ctx.lineTo(-12, 10);
          ctx.closePath();
          ctx.stroke();
        }

        ctx.restore();
      }

      function drawLine(line) {
        if (line.points.length < 2) return;
        ctx.save();
        ctx.strokeStyle = line.color;
        ctx.lineWidth = 6;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.beginPath();
        ctx.moveTo(line.points[0].x, line.points[0].y);
        for (let i = 1; i < line.points.length; i++) {
          ctx.lineTo(line.points[i].x, line.points[i].y);
        }
        ctx.stroke();
        ctx.restore();
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw lines
        for (const line of lines) {
          drawLine(line);
        }
        if (currentLine && currentLine.points.length >= 2) {
          drawLine(currentLine);
        }

        // Draw stations on top
        for (const s of stations) {
          drawStation(s);
        }
      }

      function getMousePos(e) {
        const rect = canvas.getBoundingClientRect();
        return {
          x: (e.clientX - rect.left),
          y: (e.clientY - rect.top),
        };
      }

      function findStationAt(pos, radius = 18) {
        for (const s of stations) {
          const dx = s.x - pos.x;
          const dy = s.y - pos.y;
          if (Math.sqrt(dx * dx + dy * dy) <= radius) return s;
        }
        return null;
      }

      canvas.addEventListener("click", (e) => {
        // Plain click: create station if not near an existing one
        const pos = getMousePos(e);
        const existing = findStationAt(pos);
        if (existing) return;

        const shape = shapes[stations.length % shapes.length];
        stations.push({ x: pos.x, y: pos.y, shape });
        draw();
      });

      canvas.addEventListener("mousedown", (e) => {
        const pos = getMousePos(e);
        const s = findStationAt(pos);
        if (!s) return;

        draggingFromStation = s;
        currentLine = {
          color: lineColors[lines.length % lineColors.length],
          points: [{ x: s.x, y: s.y }, { x: pos.x, y: pos.y }],
        };
      });

      canvas.addEventListener("mousemove", (e) => {
        if (!currentLine) return;
        const pos = getMousePos(e);
        currentLine.points[currentLine.points.length - 1] = pos;
        draw();
      });

      canvas.addEventListener("mouseup", (e) => {
        if (!currentLine || !draggingFromStation) return;
        const pos = getMousePos(e);
        const target = findStationAt(pos);

        if (target && target !== draggingFromStation) {
          // finalize line between two stations
          currentLine.points[currentLine.points.length - 1] = {
            x: target.x,
            y: target.y,
          };
          lines.push(currentLine);
        }

        currentLine = null;
        draggingFromStation = null;
        draw();
      });
    </script>
  </body>
</html>
