<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Mini Metro-ish</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        padding: 0;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        background: #111215;
        color: #111827;
        height: 100vh;
        display: flex;
        flex-direction: column;
      }
      header {
        padding: 8px 16px;
        font-size: 14px;
        border-bottom: 1px solid #1f2937;
        display: flex;
        justify-content: space-between;
        align-items: center;
        color: #e5e7eb;
      }
      header a {
        color: #9ca3af;
        text-decoration: none;
        font-size: 13px;
      }
      header a:hover {
        text-decoration: underline;
      }
      #canvas-wrapper {
        flex: 1;
        position: relative;
        background: #f4f4ec;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none; /* disable text selection everywhere in play area */
      }
      #metro-canvas {
        width: 100%;
        height: 100%;
        display: block;
      }
      #hud-left,
      #hud-right,
      #hint,
      #train-inventory {
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
      }
      #hud-left {
        position: absolute;
        top: 8px;
        left: 8px;
        font-size: 12px;
        color: #374151;
        background: rgba(244, 244, 236, 0.8);
        padding: 4px 8px;
        border-radius: 6px;
      }
      #hud-right {
        position: absolute;
        top: 8px;
        right: 8px;
        font-size: 12px;
        color: #374151;
        background: rgba(244, 244, 236, 0.8);
        padding: 4px 8px;
        border-radius: 6px;
        max-width: 260px;
      }
      #hint {
        position: absolute;
        left: 8px;
        bottom: 56px;
        font-size: 12px;
        color: #374151;
        background: rgba(244, 244, 236, 0.8);
        padding: 6px 8px;
        border-radius: 6px;
        max-width: 220px;
      }
      #train-inventory {
        position: absolute;
        bottom: 4px;
        left: 8px;
        display: flex;
        align-items: center;
        font-size: 12px;
        color: #374151;
        background: rgba(244, 244, 236, 0.9);
        padding: 6px 10px;
        border-radius: 999px;
        cursor: pointer;
      }
      #train-icon {
        width: 20px;
        height: 12px;
        border-radius: 4px;
        background: #111827;
        position: relative;
        margin-right: 4px;
      }
      #train-icon::before {
        content: "";
        position: absolute;
        left: 3px;
        right: 3px;
        bottom: -3px;
        height: 3px;
        border-radius: 999px;
        background: #374151;
      }
      #train-count {
        position: relative;
        padding-left: 2px;
        padding-right: 2px;
      }
      #train-count::after {
        content: attr(data-count);
        position: absolute;
        top: -6px;
        right: -10px;
        font-size: 9px;
        background: #ef4444;
        color: #f9fafb;
        border-radius: 999px;
        padding: 1px 3px;
      }
      #game-over-overlay {
        position: absolute;
        inset: 0;
        background: rgba(17, 18, 21, 0.8);
        color: #e5e7eb;
        display: none;
        align-items: center;
        justify-content: center;
      }
      #game-over-panel {
        background: #111827;
        border-radius: 12px;
        padding: 16px 20px;
        max-width: 320px;
        width: 90%;
        font-size: 13px;
      }
      #game-over-panel h2 {
        margin: 0 0 8px 0;
        font-size: 16px;
        color: #f9fafb;
      }
      #game-over-panel p {
        margin: 4px 0;
      }
      #game-over-panel button {
        margin-top: 10px;
        padding: 6px 10px;
        border-radius: 6px;
        border: none;
        background: #fbbf24;
        color: #111827;
        font-size: 12px;
        cursor: pointer;
      }
      #game-over-panel button:hover {
        background: #facc15;
      }
    </style>
  </head>
  <body>
    <header>
      <div>Mini Metro-ish prototype</div>
      <div><a href="/">Back to GAHOOT</a></div>
    </header>

    <div id="canvas-wrapper">
      <canvas id="metro-canvas"></canvas>

      <div id="hud-left">
        Lines: <span id="hud-lines">0</span> Â· Stations:
        <span id="hud-stations">0</span>
      </div>
      <div id="hud-right">
        Drag from stations/T-caps to build lines. Drag trains or the train
        bubble onto lines.
      </div>
      <div id="hint">
        Deliver passengers to matching shapes. Avoid stations exceeding 10
        waiting passengers.
      </div>

      <div id="train-inventory">
        <div id="train-icon"></div>
        <span>Trains</span>
        <span id="train-count" data-count="1"></span>
      </div>

      <div id="game-over-overlay">
        <div id="game-over-panel">
          <h2>Network Overcrowded</h2>
          <p id="go-score"></p>
          <p id="go-time"></p>
          <p id="go-lines"></p>
          <p id="go-stations"></p>
          <p id="go-cause"></p>
          <button onclick="location.reload()">Restart</button>
        </div>
      </div>
    </div>

    <script>
      // ==== SETUP ====
      const canvas = document.getElementById("metro-canvas");
      const ctx = canvas.getContext("2d");
      const wrapper = document.getElementById("canvas-wrapper");

      const hudLines = document.getElementById("hud-lines");
      const hudStations = document.getElementById("hud-stations");
      const hudScore = document.getElementById("hud-score");
      const trainCountEl = document.getElementById("train-count");
      const trainInventoryEl = document.getElementById("train-inventory");

      const gameOverOverlay = document.getElementById("game-over-overlay");
      const goScore = document.getElementById("go-score");
      const goTime = document.getElementById("go-time");
      const goLines = document.getElementById("go-lines");
      const goStations = document.getElementById("go-stations");
      const goCause = document.getElementById("go-cause");

      function resizeCanvas() {
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      window.addEventListener("resize", resizeCanvas);
      window.addEventListener("load", () => {
        resizeCanvas();
        initGame();
        lastTimestamp = performance.now();
        requestAnimationFrame(loop);
      });

      // ==== GAME STATE ====
      const stations = [];
      const lines = [];
      const trains = [];

      const stationShapes = [
        { shape: "circle", weight: 5 },
        { shape: "triangle", weight: 3 },
        { shape: "square", weight: 2 },
        { shape: "diamond", weight: 1 },
        { shape: "cross", weight: 1 },
      ];

      const lineColors = [
        "#e74c3c",
        "#f1c40f",
        "#3498db",
        "#2ecc71",
        "#9b59b6",
        "#ff7f50",
      ];

      let nextStationId = 1;
      let nextLineId = 1;
      let nextTrainId = 1;
      let score = 0;

      // pacing
      const STATION_SPAWN_INTERVAL = 12000;
      const PASSENGER_SPAWN_MIN = 5000;
      const PASSENGER_SPAWN_MAX = 10000;

      const TRAIN_SPEED = 0.2;
      const MAX_PASSENGERS_PER_TRAIN = 6;

      const TRAIN_INVENTORY_INTERVAL = 30000;
      const OVERLOAD_THRESHOLD = 10;
      const OVERLOAD_SECONDS = 45;
      const MIN_STATION_DISTANCE = 60; // slightly closer so spawn doesn't stall

      let trainInventory = 1;
      let lastTrainInventoryGain = 0;

      const overloadState = new Map();
      let gameOver = false;
      let gameStartTime = performance.now();
      let losingStationId = null;

      // dragging
      let draggingTrain = null;
      let draggingInventoryTrain = false;
      let inventoryDragPos = { x: 0, y: 0 };

      let currentLine = null;
      let draggingFromStation = null;
      let extendingLine = null; // { lineId, endIndex }

      // ==== HELPERS ====
      function segmentEase(t) {
        const edge = 0.2;
        if (t < edge) {
          return 0.3 + 0.7 * (t / edge);
        } else if (t > 1 - edge) {
          const u = (1 - t) / edge;
          return 0.3 + 0.7 * u;
        }
        return 1.4;
      }

      function randInRange(min, max) {
        return min + Math.random() * (max - min);
      }

      function distance(a, b) {
        const dx = a.x - b.x;
        const dy = a.y - b.y;
        return Math.sqrt(dx * dx + dy * dy);
      }

      function pickShapeWeighted() {
        const total = stationShapes.reduce((sum, s) => sum + s.weight, 0);
        let r = Math.random() * total;
        for (const s of stationShapes) {
          if (r < s.weight) return s.shape;
          r -= s.weight;
        }
        return "circle";
      }

      function findStationById(id) {
        return stations.find((s) => s.id === id) || null;
      }

      function worldRect() {
        const rect = canvas.getBoundingClientRect();
        return { width: rect.width, height: rect.height };
      }

      function pointOnSegment(a, b, t) {
        return {
          x: a.x + (b.x - a.x) * t,
          y: a.y + (b.y - a.y) * t,
        };
      }

      function updateTrainInventoryDisplay() {
        trainCountEl.dataset.count = trainInventory;
      }

      // ==== INITIAL GAME ====
      let lastStationSpawn = 0;

      function isFarFromExistingStations(x, y) {
        const p = { x, y };
        return stations.every((s) => distance(s, p) >= MIN_STATION_DISTANCE);
      }

      function spawnStationNearCenter() {
        const { width, height } = worldRect();
        const cx = width / 2;
        const cy = height / 2;
        const radius = Math.min(width, height) * 0.1;
        for (let i = 0; i < 40; i++) {
          const angle = Math.random() * Math.PI * 2;
          const r = randInRange(0, radius);
          const x = cx + Math.cos(angle) * r;
          const y = cy + Math.sin(angle) * r;
          if (isFarFromExistingStations(x, y)) {
            addStation(x, y);
            return;
          }
        }
        addStation(cx, cy);
      }

      function spawnStationFurtherOut() {
        const { width, height } = worldRect();
        const cx = width / 2;
        const cy = height / 2;
        for (let i = 0; i < 60; i++) {
          const radius = randInRange(
            Math.min(width, height) * 0.15,
            Math.min(width, height) * 0.45
          );
          const angle = Math.random() * Math.PI * 2;
          const x = cx + Math.cos(angle) * radius;
          const y = cy + Math.sin(angle) * radius;
          if (isFarFromExistingStations(x, y)) {
            addStation(x, y);
            return;
          }
        }
        addStation(cx, cy);
      }

      function addStation(x, y) {
        const shape = pickShapeWeighted();
        const station = {
          id: nextStationId++,
          x,
          y,
          shape,
          passengers: [],
          nextPassengerSpawn:
            performance.now() +
            randInRange(PASSENGER_SPAWN_MIN, PASSENGER_SPAWN_MAX),
        };
        stations.push(station);
      }

      function spawnPassengerAtStation(st) {
        if (stations.length < 2) return;
        const existingShapes = new Set(stations.map((s) => s.shape));
        const possibleShapes = Array.from(existingShapes).filter(
          (shape) => shape !== st.shape
        );
        if (!possibleShapes.length) return;
        const destShape =
          possibleShapes[Math.floor(Math.random() * possibleShapes.length)];
        st.passengers.push({ shape: destShape });
      }

      function initGame() {
        for (let i = 0; i < 3; i++) spawnStationNearCenter();
        lastStationSpawn = performance.now();
        lastTrainInventoryGain = performance.now();
        updateTrainInventoryDisplay();
      }

      // ==== LINES & TRAINS ====
      function createLineFromStations(stationIds) {
        if (stationIds.length < 2) return null;
        const line = {
          id: nextLineId++,
          color: lineColors[lines.length % lineColors.length],
          stations: stationIds.slice(),
          trains: [],
        };
        lines.push(line);
        if (trainInventory > 0) attachNewTrainToLine(line);
        return line;
      }

      function attachNewTrainToLine(line) {
        if (trainInventory <= 0) return;
        const train = {
          id: nextTrainId++,
          lineId: line.id,
          segmentIndex: 0,
          t: 0,
          speed: TRAIN_SPEED,
          direction: 1,
          capacity: MAX_PASSENGERS_PER_TRAIN,
          passengers: [],
          dwellQueue: [],
        };
        trains.push(train);
        line.trains.push(train.id);
        trainInventory -= 1;
        updateTrainInventoryDisplay();
      }

      function lineStations(line) {
        return line.stations.map((id) => findStationById(id)).filter(Boolean);
      }

      function computeShapeDistances(line, startIndex) {
        const n = line.stations.length;
        if (n === 0) return { forward: {}, backward: {} };
        const stationsOnLine = lineStations(line);
        const forward = {};
        const backward = {};
        for (let step = 1; step < n; step++) {
          const idx = (startIndex + step) % n;
          const st = stationsOnLine[idx];
          if (!(st.shape in forward)) forward[st.shape] = step;
        }
        for (let step = 1; step < n; step++) {
          const idx = (startIndex - step + n) % n;
          const st = stationsOnLine[idx];
          if (!(st.shape in backward)) backward[st.shape] = step;
        }
        return { forward, backward };
      }

      // ==== RENDERING ====
      function drawStationShape(station) {
        ctx.save();
        ctx.translate(station.x, station.y);
        ctx.lineWidth = 3;

        if (station.id === losingStationId) {
          ctx.strokeStyle = "#ef4444";
          ctx.fillStyle = "#fee2e2";
          ctx.beginPath();
          ctx.arc(0, 0, 18, 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.strokeStyle = "#111827";
        ctx.fillStyle = "#f9fafb";
        const shape = station.shape;

        if (shape === "circle") {
          ctx.beginPath();
          ctx.arc(0, 0, 10, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
        } else if (shape === "square") {
          ctx.beginPath();
          ctx.rect(-10, -10, 20, 20);
          ctx.fill();
          ctx.stroke();
        } else if (shape === "triangle") {
          ctx.beginPath();
          ctx.moveTo(0, -12);
          ctx.lineTo(12, 10);
          ctx.lineTo(-12, 10);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
        } else if (shape === "diamond") {
          ctx.beginPath();
          ctx.moveTo(0, -12);
          ctx.lineTo(12, 0);
          ctx.lineTo(0, 12);
          ctx.lineTo(-12, 0);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
        } else if (shape === "cross") {
          ctx.beginPath();
          ctx.moveTo(-4, -12);
          ctx.lineTo(4, -12);
          ctx.lineTo(4, -4);
          ctx.lineTo(12, -4);
          ctx.lineTo(12, 4);
          ctx.lineTo(4, 4);
          ctx.lineTo(4, 12);
          ctx.lineTo(-4, 12);
          ctx.lineTo(-4, 4);
          ctx.lineTo(-12, 4);
          ctx.lineTo(-12, -4);
          ctx.lineTo(-4, -4);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
        }
        ctx.restore();
      }

      function drawLines() {
        for (const line of lines) {
          const sts = lineStations(line);
          if (sts.length < 2) continue;

          ctx.save();
          ctx.strokeStyle = line.color;
          ctx.lineWidth = 6;
          ctx.lineCap = "round";
          ctx.lineJoin = "round";

          ctx.beginPath();
          ctx.moveTo(sts[0].x, sts[0].y);
          for (let i = 1; i < sts.length; i++) {
            ctx.lineTo(sts[i].x, sts[i].y);
          }
          ctx.stroke();

          drawLineEndCap(sts[0], sts[1]);
          drawLineEndCap(sts[sts.length - 1], sts[sts.length - 2]);
          ctx.restore();
        }

        if (currentLine && currentLine.points.length >= 2) {
          ctx.save();
          ctx.strokeStyle = currentLine.color;
          ctx.lineWidth = 6;
          ctx.lineCap = "round";
          ctx.lineJoin = "round";
          ctx.beginPath();
          ctx.moveTo(currentLine.points[0].x, currentLine.points[0].y);
          for (let i = 1; i < currentLine.points.length; i++) {
            ctx.lineTo(currentLine.points[i].x, currentLine.points[i].y);
          }
          ctx.stroke();
          ctx.restore();
        }
      }

      function drawLineEndCap(A, B) {
        const dx = B.x - A.x;
        const dy = B.y - A.y;
        const len = Math.sqrt(dx * dx + dy * dy) || 1;
        const capLength = 24; // further out than before
        const px = -dy / len;
        const py = dx / len;

        ctx.beginPath();
        ctx.moveTo(A.x + px * capLength, A.y + py * capLength);
        ctx.lineTo(A.x - px * capLength, A.y - py * capLength);
        ctx.stroke();
      }

      function drawPassengers() {
        ctx.save();
        for (const st of stations) {
          if (!st.passengers.length) continue;
          let offsetX = -5 * (st.passengers.length - 1) * 0.5;
          const y = st.y + 18;
          ctx.fillStyle = "#111827";
          for (let i = 0; i < st.passengers.length; i++) {
            ctx.beginPath();
            ctx.arc(st.x + offsetX, y, 3.5, 0, Math.PI * 2);
            ctx.fill();
            offsetX += 5;
          }
        }
        ctx.restore();
      }

      function drawOverloadPie() {
        for (const st of stations) {
          const state = overloadState.get(st.id);
          if (!state || state.timer <= 0) continue;
          const ratio = Math.min(1, state.timer / OVERLOAD_SECONDS);
          const angle = ratio * Math.PI * 2;

          ctx.save();
          ctx.translate(st.x, st.y);
          ctx.beginPath();
          ctx.fillStyle = "rgba(239, 68, 68, 0.7)";
          ctx.moveTo(0, 0);
          ctx.arc(0, 0, 18, -Math.PI / 2, -Math.PI / 2 + angle);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        }
      }

      function drawPassengerShapeAtOffset(shape, x, y, size) {
        ctx.save();
        ctx.translate(x, y);
        ctx.fillStyle = "#f4f4ec";
        ctx.strokeStyle = "#f4f4ec";
        ctx.lineWidth = 1;

        if (shape === "circle") {
          ctx.beginPath();
          ctx.arc(0, 0, size, 0, Math.PI * 2);
          ctx.fill();
        } else if (shape === "square") {
          ctx.beginPath();
          ctx.rect(-size, -size, size * 2, size * 2);
          ctx.fill();
        } else if (shape === "triangle") {
          ctx.beginPath();
          ctx.moveTo(0, -size);
          ctx.lineTo(size, size);
          ctx.lineTo(-size, size);
          ctx.closePath();
          ctx.fill();
        } else if (shape === "diamond") {
          ctx.beginPath();
          ctx.moveTo(0, -size);
          ctx.lineTo(size, 0);
          ctx.lineTo(0, size);
          ctx.lineTo(-size, 0);
          ctx.closePath();
          ctx.fill();
        } else if (shape === "cross") {
          const s = size * 0.7;
          ctx.beginPath();
          ctx.moveTo(-s / 2, -size);
          ctx.lineTo(s / 2, -size);
          ctx.lineTo(s / 2, -s / 2);
          ctx.lineTo(size, -s / 2);
          ctx.lineTo(size, s / 2);
          ctx.lineTo(s / 2, s / 2);
          ctx.lineTo(s / 2, size);
          ctx.lineTo(-s / 2, size);
          ctx.lineTo(-s / 2, s / 2);
          ctx.lineTo(-size, s / 2);
          ctx.lineTo(-size, -s / 2);
          ctx.lineTo(-s / 2, -s / 2);
          ctx.closePath();
          ctx.fill();
        }
        ctx.restore();
      }

      function drawTrains() {
        for (const tr of trains) {
          const line = lines.find((l) => l.id === tr.lineId);
          if (!line) continue;
          const sts = lineStations(line);
          if (sts.length < 2) continue;

          const segIdx = tr.segmentIndex;
          const aIdx = segIdx;
          const bIdx = (segIdx + 1) % sts.length;
          const A = sts[aIdx];
          const B = sts[bIdx];
          const pos =
            draggingTrain === tr
              ? draggingTrain.dragPos
              : pointOnSegment(A, B, tr.t);

          ctx.save();
          ctx.translate(pos.x, pos.y);
          const dx = B.x - A.x;
          const dy = B.y - A.y;
          const ang = Math.atan2(dy, dx);
          ctx.rotate(ang);

          ctx.fillStyle = "#111827";
          ctx.strokeStyle = "#fdfdf6";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.rect(-14, -7, 28, 14);
          ctx.fill();
          ctx.stroke();

          const maxShow = Math.min(6, tr.passengers.length);
          const cols = 3;
          const cellW = 6;
          const cellH = 6;
          const startX = -cellW * (cols - 1) * 0.5;
          const startY = -cellH * 0.5;
          for (let i = 0; i < maxShow; i++) {
            const p = tr.passengers[i];
            const col = i % cols;
            const row = Math.floor(i / cols);
            const x = startX + col * cellW;
            const y = startY + row * cellH;
            drawPassengerShapeAtOffset(p.shape, x, y, 2);
          }

          ctx.restore();
        }

        if (draggingInventoryTrain) {
          const pos = inventoryDragPos;
          ctx.save();
          ctx.fillStyle = "#111827";
          ctx.strokeStyle = "#fdfdf6";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.rect(pos.x - 14, pos.y - 7, 28, 14);
          ctx.fill();
          ctx.stroke();
          ctx.restore();
        }
      }

      function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const rect = canvas.getBoundingClientRect();
        ctx.save();
        ctx.strokeStyle = "#e5e5dc";
        ctx.lineWidth = 1;
        const step = 40;
        for (let x = 0; x < rect.width; x += step) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, rect.height);
          ctx.stroke();
        }
        for (let y = 0; y < rect.height; y += step) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(rect.width, y);
          ctx.stroke();
        }
        ctx.restore();

        drawLines();
        for (const st of stations) drawStationShape(st);
        drawOverloadPie();
        drawPassengers();
        drawTrains();

        hudLines.textContent = lines.length;
        hudStations.textContent = stations.length;
        hudScore && (hudScore.textContent = score);
      }

      // ==== INPUT ====
      function getMousePos(e) {
        const rect = canvas.getBoundingClientRect();
        return { x: e.clientX - rect.left, y: e.clientY - rect.top };
      }

      function findStationAt(pos, radius = 18) {
        for (const s of stations) {
          const dx = s.x - pos.x;
          const dy = s.y - pos.y;
          if (Math.sqrt(dx * dx + dy * dy) <= radius) return s;
        }
        return null;
      }

      function findTrainAt(pos, radius = 12) {
        for (const tr of trains) {
          const line = lines.find((l) => l.id === tr.lineId);
          if (!line) continue;
          const sts = lineStations(line);
          if (sts.length < 2) continue;
          const A = sts[tr.segmentIndex];
          const B = sts[(tr.segmentIndex + 1) % sts.length];
          const p = pointOnSegment(A, B, tr.t);
          const dx = p.x - pos.x;
          const dy = p.y - pos.y;
          if (Math.sqrt(dx * dx + dy * dy) <= radius)
            return { tr, pos: p };
        }
        return null;
      }

      function distancePointToSegment(p, a, b) {
        const vx = b.x - a.x;
        const vy = b.y - a.y;
        const wx = p.x - a.x;
        const wy = p.y - a.y;
        const c1 = vx * wx + vy * wy;
        if (c1 <= 0) return distance(p, a);
        const c2 = vx * vx + vy * vy;
        if (c2 <= c1) return distance(p, b);
        const t = c1 / c2;
        const proj = { x: a.x + t * vx, y: a.y + t * vy };
        return distance(p, proj);
      }

      function findLineNearestPoint(pos, threshold = 10) {
        let bestLine = null;
        let bestDist = threshold;
        for (const line of lines) {
          const sts = lineStations(line);
          if (sts.length < 2) continue;
          for (let i = 0; i < sts.length - 1; i++) {
            const A = sts[i];
            const B = sts[i + 1];
            const dist = distancePointToSegment(pos, A, B);
            if (dist < bestDist) {
              bestDist = dist;
              bestLine = line;
            }
          }
        }
        return bestLine;
      }

      function findLineEndpointAt(pos, radius = 16) {
        for (const line of lines) {
          const sts = lineStations(line);
          if (sts.length < 2) continue;
          const endpoints = [
            { station: sts[0], index: 0 },
            { station: sts[sts.length - 1], index: sts.length - 1 },
          ];
          for (const ep of endpoints) {
            const dx = ep.station.x - pos.x;
            const dy = ep.station.y - pos.y;
            if (Math.sqrt(dx * dx + dy * dy) <= radius) {
              return { line, endIndex: ep.index };
            }
          }
        }
        return null;
      }

      // drag from inventory bubble
      wrapper.addEventListener("mousedown", (e) => {
        if (gameOver) return;
        const target = e.target;
        if (
          (target === trainInventoryEl ||
            trainInventoryEl.contains(target)) &&
          trainInventory > 0
        ) {
          draggingInventoryTrain = true;
          inventoryDragPos = getMousePos(e);
          e.preventDefault();
        }
      });

      canvas.addEventListener("mousedown", (e) => {
        if (gameOver) return;
        const pos = getMousePos(e);

        const hitTrain = findTrainAt(pos);
        if (hitTrain) {
          draggingTrain = hitTrain.tr;
          draggingTrain.dragPos = { x: pos.x, y: pos.y };
          return;
        }

        const endpointHit = findLineEndpointAt(pos);
        if (endpointHit) {
          extendingLine = {
            lineId: endpointHit.line.id,
            endIndex: endpointHit.endIndex,
          };
          return;
        }

        const s = findStationAt(pos);
        if (!s) return;

        draggingFromStation = s;
        currentLine = {
          color: lineColors[lines.length % lineColors.length],
          points: [{ x: s.x, y: s.y }],
          stationIds: [s.id],
        };
      });

      canvas.addEventListener("mousemove", (e) => {
        const pos = getMousePos(e);

        if (draggingInventoryTrain) {
          inventoryDragPos = pos;
          render();
          return;
        }

        if (draggingTrain) {
          draggingTrain.dragPos = { x: pos.x, y: pos.y };
          render();
          return;
        }

        if (extendingLine) return;

        if (!currentLine) return;
        currentLine.points[currentLine.points.length - 1] = pos;
        render();
      });

      canvas.addEventListener("mouseup", (e) => {
        const pos = getMousePos(e);

        if (draggingInventoryTrain) {
          draggingInventoryTrain = false;
          const line = findLineNearestPoint(pos);
          if (line) attachNewTrainToLine(line);
          render();
          return;
        }

        if (draggingTrain) {
          const line = findLineNearestPoint(pos);
          if (line) {
            const oldLine = lines.find((l) => l.id === draggingTrain.lineId);
            if (oldLine) {
              oldLine.trains = oldLine.trains.filter(
                (id) => id !== draggingTrain.id
              );
            }
            draggingTrain.lineId = line.id;
            draggingTrain.segmentIndex = 0;
            draggingTrain.t = 0;
            line.trains.push(draggingTrain.id);
          }
          draggingTrain = null;
          render();
          return;
        }

        if (extendingLine) {
          const line = lines.find((l) => l.id === extendingLine.lineId);
          const sts = lineStations(line);
          const target = findStationAt(pos);
          if (target) {
            const atEnd = extendingLine.endIndex === sts.length - 1;
            const atStart = extendingLine.endIndex === 0;
            if (atEnd) {
              if (line.stations[line.stations.length - 1] !== target.id) {
                line.stations.push(target.id);
              }
            } else if (atStart) {
              if (line.stations[0] !== target.id) {
                line.stations.unshift(target.id);
              }
            }
          }
          extendingLine = null;
          render();
          return;
        }

        if (!currentLine || !draggingFromStation) {
          currentLine = null;
          draggingFromStation = null;
          return;
        }
        const target = findStationAt(pos);
        if (target && target.id !== draggingFromStation.id) {
          currentLine.points[currentLine.points.length - 1] = {
            x: target.x,
            y: target.y,
          };
          currentLine.stationIds.push(target.id);
          createLineFromStations(currentLine.stationIds);
        }
        currentLine = null;
        draggingFromStation = null;
        render();
      });

      canvas.addEventListener("mouseleave", () => {
        draggingTrain = null;
        draggingInventoryTrain = false;
        extendingLine = null;
        currentLine = null;
        draggingFromStation = null;
        render();
      });

      // ==== REWARD / EXTRA TRAINS ====
      // Just auto-gain inventory over time now (no popup)
      function updateInventoryTimer(now) {
        if (now - lastTrainInventoryGain > TRAIN_INVENTORY_INTERVAL) {
          trainInventory += 1;
          lastTrainInventoryGain = now;
          updateTrainInventoryDisplay();
        }
      }

      // ==== SIMULATION ====
      let lastTimestamp = 0;

      function update(dt) {
        if (gameOver) return;
        const now = performance.now();

        if (now - lastStationSpawn > STATION_SPAWN_INTERVAL) {
          if (stations.length < 6) spawnStationNearCenter();
          else spawnStationFurtherOut();
          lastStationSpawn = now;
        }

        for (const st of stations) {
          if (now >= st.nextPassengerSpawn) {
            spawnPassengerAtStation(st);
            st.nextPassengerSpawn =
              now + randInRange(PASSENGER_SPAWN_MIN, PASSENGER_SPAWN_MAX);
          }
        }

        updateInventoryTimer(now);

        for (const st of stations) {
          let state = overloadState.get(st.id);
          if (!state) {
            state = { timer: 0 };
            overloadState.set(st.id, state);
          }
          const count = st.passengers.length;
          if (count >= OVERLOAD_THRESHOLD) {
            state.timer += dt;
            if (state.timer >= OVERLOAD_SECONDS) {
              losingStationId = st.id;
              triggerGameOver();
              break;
            }
          } else if (state.timer > 0) {
            state.timer -= dt;
            if (state.timer < 0) state.timer = 0;
          }
        }

        for (const tr of trains) {
          if (draggingTrain === tr) continue;

          if (tr.dwellQueue.length > 0) {
            tr.dwellQueue[0].time -= dt;
            if (tr.dwellQueue[0].time <= 0) {
              const action = tr.dwellQueue.shift();
              action.run();
            }
            continue;
          }

          const line = lines.find((l) => l.id === tr.lineId);
          if (!line) continue;
          const sts = lineStations(line);
          if (sts.length < 2) continue;

          const n = sts.length;
          let segIdx = tr.segmentIndex;
          let aIdx = segIdx;
          let bIdx = (segIdx + tr.direction + n) % n;
          let A = sts[aIdx];
          let B = sts[bIdx];

          const factor = segmentEase(tr.t);
          tr.t += tr.speed * factor * dt;

          if (tr.t >= 1) {
            tr.t = 0;
            tr.segmentIndex = bIdx;
            A = sts[tr.segmentIndex];
            handleTrainAtStation(tr, line, A);
          }
        }
      }

      function handleTrainAtStation(tr, line, station) {
        const dwell = [];

        const remaining = [];
        for (const p of tr.passengers) {
          const destStation = stations.find((st) => st.id === p.destStationId);
          if (destStation && destStation.id === station.id) {
            dwell.push({
              time: 0.2,
              run: () => {
                score += 1;
              },
            });
          } else {
            remaining.push(p);
          }
        }
        tr.passengers = remaining;

        const sts = lineStations(line);
        const currentIndex = sts.findIndex((st) => st.id === station.id);
        if (currentIndex === -1) {
          tr.dwellQueue = dwell;
          return;
        }

        const shapeDistances = computeShapeDistances(line, currentIndex);
        const chosenDir = tr.direction === 1 ? "forward" : "backward";

        const lineTrains = line.trains
          .map((id) => trains.find((t) => t.id === id))
          .filter(Boolean);
        const hasOppositeTrain = lineTrains.some(
          (t) => t.direction === (tr.direction === 1 ? -1 : 1)
        );

        const boardCandidates = [];
        for (const p of station.passengers) {
          const destShape = p.shape;
          const forwardDist = shapeDistances.forward[destShape];
          const backwardDist = shapeDistances.backward[destShape];

          if (forwardDist == null && backwardDist == null) continue;

          let bestDir = null;
          if (forwardDist != null && backwardDist == null) bestDir = "forward";
          else if (backwardDist != null && forwardDist == null)
            bestDir = "backward";
          else bestDir = forwardDist <= backwardDist ? "forward" : "backward";

          const mayBoard =
            !hasOppositeTrain
              ? shapeDistances[chosenDir][destShape] != null
              : bestDir === chosenDir;

          if (mayBoard) {
            const destId = findDestinationStationIdAlongLine(
              line,
              currentIndex,
              chosenDir,
              destShape
            );
            if (destId != null) {
              boardCandidates.push({ passenger: p, destStationId: destId });
            }
          }
        }

        for (const cand of boardCandidates) {
          if (tr.passengers.length >= tr.capacity) break;
          dwell.push({
            time: 0.2,
            run: () => {
              const idx = station.passengers.indexOf(cand.passenger);
              if (idx !== -1) station.passengers.splice(idx, 1);
              tr.passengers.push({
                shape: cand.passenger.shape,
                destStationId: cand.destStationId,
              });
            },
          });
        }

        tr.dwellQueue = dwell;
      }

      function findDestinationStationIdAlongLine(
        line,
        startIndex,
        dirName,
        shape
      ) {
        const sts = lineStations(line);
        const n = sts.length;
        const step = dirName === "forward" ? 1 : -1;
        for (let k = 1; k < n; k++) {
          const idx = (startIndex + step * k + n) % n;
          if (sts[idx].shape === shape) return sts[idx].id;
        }
        return null;
      }

      function triggerGameOver() {
        if (gameOver) return;
        gameOver = true;
        gameOverOverlay.style.display = "flex";

        const now = performance.now();
        const seconds = Math.round((now - gameStartTime) / 1000);

        goScore.textContent = "Passengers delivered: " + score;
        goTime.textContent = "Time survived: " + seconds + "s";
        goLines.textContent = "Lines built: " + lines.length;
        goStations.textContent = "Stations spawned: " + stations.length;
        const st = losingStationId ? findStationById(losingStationId) : null;
        if (st) {
          goCause.textContent =
            "Overcrowded station shape: " + st.shape + " (id " + st.id + ")";
        } else {
          goCause.textContent = "A station overcrowded.";
        }
      }

      // ==== MAIN LOOP ====
      function loop(timestamp) {
        const dt = (timestamp - lastTimestamp) / 1000;
        lastTimestamp = timestamp;
        update(dt);
        render();
        requestAnimationFrame(loop);
      }
    </script>
  </body>
</html>
