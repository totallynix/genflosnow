<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Mini Metro-ish</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        padding: 0;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        background: #111215;
        color: #111827;
        height: 100vh;
        display: flex;
        flex-direction: column;
      }
      header {
        padding: 8px 16px;
        font-size: 14px;
        border-bottom: 1px solid #1f2937;
        display: flex;
        justify-content: space-between;
        align-items: center;
        color: #e5e7eb;
      }
      header a {
        color: #9ca3af;
        text-decoration: none;
        font-size: 13px;
      }
      header a:hover {
        text-decoration: underline;
      }
      #canvas-wrapper {
        flex: 1;
        position: relative;
        background: #f4f4ec;
      }
      #metro-canvas {
        width: 100%;
        height: 100%;
        display: block;
      }
      #hud-left {
        position: absolute;
        top: 8px;
        left: 8px;
        font-size: 12px;
        color: #374151;
        background: rgba(244, 244, 236, 0.8);
        padding: 4px 8px;
        border-radius: 6px;
      }
      #hud-right {
        position: absolute;
        top: 8px;
        right: 8px;
        font-size: 12px;
        color: #374151;
        background: rgba(244, 244, 236, 0.8);
        padding: 4px 8px;
        border-radius: 6px;
      }
      #hint {
        position: absolute;
        left: 8px;
        bottom: 32px;
        font-size: 12px;
        color: #374151;
        background: rgba(244, 244, 236, 0.8);
        padding: 6px 8px;
        border-radius: 6px;
      }
      #train-inventory {
        position: absolute;
        bottom: 4px;
        left: 8px;
        display: flex;
        align-items: center;
        font-size: 12px;
        color: #374151;
        background: rgba(244, 244, 236, 0.9);
        padding: 4px 8px;
        border-radius: 999px;
      }
      #train-icon {
        width: 20px;
        height: 12px;
        border-radius: 4px;
        background: #111827;
        position: relative;
        margin-right: 4px;
      }
      #train-icon::before {
        content: "";
        position: absolute;
        left: 3px;
        right: 3px;
        bottom: -3px;
        height: 3px;
        border-radius: 999px;
        background: #374151;
      }
      #train-count {
        position: relative;
        padding-left: 2px;
        padding-right: 2px;
      }
      #train-count::after {
        /* small superscript-like bubble */
        content: attr(data-count);
        position: absolute;
        top: -6px;
        right: -10px;
        font-size: 9px;
        background: #ef4444;
        color: #f9fafb;
        border-radius: 999px;
        padding: 1px 3px;
      }
      #game-over-overlay {
        position: absolute;
        inset: 0;
        background: rgba(17, 18, 21, 0.8);
        color: #e5e7eb;
        display: none;
        align-items: center;
        justify-content: center;
      }
      #game-over-panel {
        background: #111827;
        border-radius: 12px;
        padding: 16px 20px;
        max-width: 320px;
        width: 90%;
        font-size: 13px;
      }
      #game-over-panel h2 {
        margin: 0 0 8px 0;
        font-size: 16px;
        color: #f9fafb;
      }
      #game-over-panel p {
        margin: 4px 0;
      }
      #game-over-panel button {
        margin-top: 10px;
        padding: 6px 10px;
        border-radius: 6px;
        border: none;
        background: #fbbf24;
        color: #111827;
        font-size: 12px;
        cursor: pointer;
      }
      #game-over-panel button:hover {
        background: #facc15;
      }
    </style>
  </head>
  <body>
    <header>
      <div>Mini Metro-ish prototype</div>
      <div><a href="/">Back to GAHOOT</a></div>
    </header>

    <div id="canvas-wrapper">
      <canvas id="metro-canvas"></canvas>
      <div id="hud-left">
        Lines: <span id="hud-lines">0</span> Â· Stations:
        <span id="hud-stations">0</span>
      </div>
      <div id="hud-right">
        Score: <span id="hud-score">0</span>
      </div>
      <div id="hint">
        Stations spawn over time. Drag from a station through others to draw a
        line. Trains move automatically and deliver matching shapes.
      </div>

      <div id="train-inventory">
        <div id="train-icon"></div>
        <span>Trains</span>
        <span id="train-count" data-count="0"></span>
      </div>

      <div id="game-over-overlay">
        <div id="game-over-panel">
          <h2>Network Overcrowded</h2>
          <p id="go-score"></p>
          <p id="go-time"></p>
          <p id="go-lines"></p>
          <p id="go-stations"></p>
          <p id="go-cause"></p>
          <button onclick="location.reload()">Restart</button>
        </div>
      </div>
    </div>

    <script>
      // ==== SETUP ====
      const canvas = document.getElementById("metro-canvas");
      const ctx = canvas.getContext("2d");

      const hudLines = document.getElementById("hud-lines");
      const hudStations = document.getElementById("hud-stations");
      const hudScore = document.getElementById("hud-score");
      const trainCountEl = document.getElementById("train-count");
      const gameOverOverlay = document.getElementById("game-over-overlay");
      const goScore = document.getElementById("go-score");
      const goTime = document.getElementById("go-time");
      const goLines = document.getElementById("go-lines");
      const goStations = document.getElementById("go-stations");
      const goCause = document.getElementById("go-cause");

      function resizeCanvas() {
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      window.addEventListener("resize", resizeCanvas);
      window.addEventListener("load", () => {
        resizeCanvas();
        initGame();
        lastTimestamp = performance.now();
        requestAnimationFrame(loop);
      });

      // ==== GAME STATE ====
      const stations = [];
      const lines = [];
      const trains = [];

      const stationShapes = [
        { shape: "circle", weight: 5 },
        { shape: "triangle", weight: 3 },
        { shape: "square", weight: 2 },
        { shape: "diamond", weight: 1 },
        { shape: "cross", weight: 1 },
      ];

      const lineColors = [
        "#e74c3c",
        "#3498db",
        "#2ecc71",
        "#f1c40f",
        "#9b59b6",
        "#ff7f50",
      ];

      let nextStationId = 1;
      let nextLineId = 1;
      let nextTrainId = 1;
      let score = 0;

      // Balancable parameters
      const STATION_SPAWN_INTERVAL = 8000;
      const PASSENGER_SPAWN_MIN = 3000;
      const PASSENGER_SPAWN_MAX = 7000;
      const TRAIN_SPEED = 0.2;
      const BOARDING_TIME_PER_PASSENGER = 0.3;
      const MAX_PASSENGERS_PER_TRAIN = 6;

      const TRAIN_INVENTORY_INTERVAL = 30000; // ms per extra train
      const OVERLOAD_THRESHOLD = 10; // passengers
      const OVERLOAD_SECONDS = 45; // time for pie to fill

      let trainInventory = 1; // start with 1 train available
      let lastTrainInventoryGain = 0;

      // overcrowding state per station: {timer}
      const overloadState = new Map();
      let gameOver = false;
      let gameStartTime = performance.now();
      let losingStationId = null;

      // ==== HELPERS ====
      function randInRange(min, max) {
        return min + Math.random() * (max - min);
      }

      function pickShapeWeighted() {
        const total = stationShapes.reduce((sum, s) => sum + s.weight, 0);
        let r = Math.random() * total;
        for (const s of stationShapes) {
          if (r < s.weight) return s.shape;
          r -= s.weight;
        }
        return "circle";
      }

      function findStationById(id) {
        return stations.find((s) => s.id === id) || null;
      }

      function worldRect() {
        const rect = canvas.getBoundingClientRect();
        return { width: rect.width, height: rect.height };
      }

      function pointOnSegment(a, b, t) {
        return {
          x: a.x + (b.x - a.x) * t,
          y: a.y + (b.y - a.y) * t,
        };
      }

      function updateTrainInventoryDisplay() {
        trainCountEl.dataset.count = trainInventory;
      }

      // ==== INITIAL GAME SETUP ====
      let lastStationSpawn = 0;

      function spawnStationNearCenter() {
        const { width, height } = worldRect();
        const cx = width / 2;
        const cy = height / 2;

        const radius = Math.min(width, height) * 0.1;
        const angle = Math.random() * Math.PI * 2;
        const x = cx + Math.cos(angle) * randInRange(0, radius);
        const y = cy + Math.sin(angle) * randInRange(0, radius);

        addStation(x, y);
      }

      function spawnStationFurtherOut() {
        const { width, height } = worldRect();
        const cx = width / 2;
        const cy = height / 2;

        const radius = randInRange(
          Math.min(width, height) * 0.15,
          Math.min(width, height) * 0.45
        );
        const angle = Math.random() * Math.PI * 2;
        const x = cx + Math.cos(angle) * radius;
        const y = cy + Math.sin(angle) * radius;

        addStation(x, y);
      }

      function addStation(x, y) {
        const shape = pickShapeWeighted();
        const station = {
          id: nextStationId++,
          x,
          y,
          shape,
          passengers: [],
          nextPassengerSpawn:
            performance.now() +
            randInRange(PASSENGER_SPAWN_MIN, PASSENGER_SPAWN_MAX),
        };
        stations.push(station);
      }

      function spawnPassengerAtStation(st) {
        if (stations.length < 2) return;
        const possibleShapes = stationShapes
          .map((s) => s.shape)
          .filter((sh) => sh !== st.shape);
        const destShape =
          possibleShapes[Math.floor(Math.random() * possibleShapes.length)];
        st.passengers.push({ shape: destShape });
      }

      function initGame() {
        for (let i = 0; i < 3; i++) {
          spawnStationNearCenter();
        }
        lastStationSpawn = performance.now();
        lastTrainInventoryGain = performance.now();
        updateTrainInventoryDisplay();
      }

      // ==== LINES & TRAINS ====
      let currentLine = null;
      let draggingFromStation = null;

      function createLineFromStations(stationIds) {
        if (stationIds.length < 2) return null;
        const line = {
          id: nextLineId++,
          color: lineColors[lines.length % lineColors.length],
          stations: stationIds.slice(),
          trains: [],
        };
        lines.push(line);

        // Place one train only if inventory available
        if (trainInventory > 0) {
          const train = {
            id: nextTrainId++,
            lineId: line.id,
            segmentIndex: 0,
            t: 0,
            speed: TRAIN_SPEED,
            direction: 1,
            capacity: MAX_PASSENGERS_PER_TRAIN,
            passengers: [],
            boardingTimer: 0,
          };
          trains.push(train);
          line.trains.push(train.id);
          trainInventory -= 1;
          updateTrainInventoryDisplay();
        }

        return line;
      }

      function lineStations(line) {
        return line.stations.map((id) => findStationById(id)).filter(Boolean);
      }

      function computeShapeDistances(line, startIndex) {
        const n = line.stations.length;
        if (n === 0) return { forward: {}, backward: {} };

        const stationsOnLine = lineStations(line);
        const forward = {};
        const backward = {};

        for (let step = 1; step < n; step++) {
          const idx = (startIndex + step) % n;
          const st = stationsOnLine[idx];
          if (!(st.shape in forward)) {
            forward[st.shape] = step;
          }
        }

        for (let step = 1; step < n; step++) {
          const idx = (startIndex - step + n) % n;
          const st = stationsOnLine[idx];
          if (!(st.shape in backward)) {
            backward[st.shape] = step;
          }
        }

        return { forward, backward };
      }

      // ==== RENDERING ====
      function drawStationShape(station) {
        ctx.save();
        ctx.translate(station.x, station.y);
        ctx.lineWidth = 3;

        // highlight if this is the losing station
        if (station.id === losingStationId) {
          ctx.strokeStyle = "#ef4444";
          ctx.fillStyle = "#fee2e2";
          ctx.beginPath();
          ctx.arc(0, 0, 18, 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.strokeStyle = "#111827";
        ctx.fillStyle = "#f9fafb";

        const shape = station.shape;
        if (shape === "circle") {
          ctx.beginPath();
          ctx.arc(0, 0, 10, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
        } else if (shape === "square") {
          ctx.beginPath();
          ctx.rect(-10, -10, 20, 20);
          ctx.fill();
          ctx.stroke();
        } else if (shape === "triangle") {
          ctx.beginPath();
          ctx.moveTo(0, -12);
          ctx.lineTo(12, 10);
          ctx.lineTo(-12, 10);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
        } else if (shape === "diamond") {
          ctx.beginPath();
          ctx.moveTo(0, -12);
          ctx.lineTo(12, 0);
          ctx.lineTo(0, 12);
          ctx.lineTo(-12, 0);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
        } else if (shape === "cross") {
          ctx.beginPath();
          ctx.moveTo(-4, -12);
          ctx.lineTo(4, -12);
          ctx.lineTo(4, -4);
          ctx.lineTo(12, -4);
          ctx.lineTo(12, 4);
          ctx.lineTo(4, 4);
          ctx.lineTo(4, 12);
          ctx.lineTo(-4, 12);
          ctx.lineTo(-4, 4);
          ctx.lineTo(-12, 4);
          ctx.lineTo(-12, -4);
          ctx.lineTo(-4, -4);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
        }

        ctx.restore();
      }

      function drawLines() {
        for (const line of lines) {
          const sts = lineStations(line);
          if (sts.length < 2) continue;

          ctx.save();
          ctx.strokeStyle = line.color;
          ctx.lineWidth = 6;
          ctx.lineCap = "round";
          ctx.lineJoin = "round";

          ctx.beginPath();
          ctx.moveTo(sts[0].x, sts[0].y);
          for (let i = 1; i < sts.length; i++) {
            ctx.lineTo(sts[i].x, sts[i].y);
          }
          ctx.stroke();

          drawLineEndCap(sts[0], sts[1]);
          drawLineEndCap(sts[sts.length - 1], sts[sts.length - 2]);
          ctx.restore();
        }

        if (currentLine && currentLine.points.length >= 2) {
          ctx.save();
          ctx.strokeStyle = currentLine.color;
          ctx.lineWidth = 6;
          ctx.lineCap = "round";
          ctx.lineJoin = "round";
          ctx.beginPath();
          ctx.moveTo(currentLine.points[0].x, currentLine.points[0].y);
          for (let i = 1; i < currentLine.points.length; i++) {
            ctx.lineTo(currentLine.points[i].x, currentLine.points[i].y);
          }
          ctx.stroke();
          ctx.restore();
        }
      }

      function drawLineEndCap(A, B) {
        const dx = B.x - A.x;
        const dy = B.y - A.y;
        const len = Math.sqrt(dx * dx + dy * dy) || 1;
        const ux = dx / len;
        const uy = dy / len;

        const capLength = 10;
        const px = -uy;
        const py = ux;

        ctx.beginPath();
        ctx.moveTo(A.x + px * capLength, A.y + py * capLength);
        ctx.lineTo(A.x - px * capLength, A.y - py * capLength);
        ctx.stroke();
      }

      function drawPassengers() {
        ctx.save();
        ctx.font = "10px system-ui, sans-serif";
        for (const st of stations) {
          if (!st.passengers.length) continue;
          let offsetX = -8 * (st.passengers.length - 1) * 0.5;
          let y = st.y + 18;

          for (const p of st.passengers) {
            ctx.fillStyle = "#111827";
            ctx.beginPath();
            ctx.arc(st.x + offsetX, y, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#f4f4ec";
            ctx.fillText(p.shape[0].toUpperCase(), st.x + offsetX - 3, y + 3);
            offsetX += 8;
          }
        }
        ctx.restore();
      }

      function drawOverloadPie() {
        for (const st of stations) {
          const state = overloadState.get(st.id);
          if (!state || state.timer <= 0) continue;
          const ratio = Math.min(1, state.timer / OVERLOAD_SECONDS);
          const angle = ratio * Math.PI * 2;

          ctx.save();
          ctx.translate(st.x, st.y);
          ctx.beginPath();
          ctx.fillStyle = "rgba(239, 68, 68, 0.7)";
          ctx.moveTo(0, 0);
          ctx.arc(0, 0, 18, -Math.PI / 2, -Math.PI / 2 + angle);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        }
      }

      function drawTrains() {
        for (const tr of trains) {
          const line = lines.find((l) => l.id === tr.lineId);
          if (!line) continue;
          const sts = lineStations(line);
          if (sts.length < 2) continue;

          const segIdx = tr.segmentIndex;
          const aIdx = segIdx;
          const bIdx = (segIdx + 1) % sts.length;
          const A = sts[aIdx];
          const B = sts[bIdx];
          const pos = pointOnSegment(A, B, tr.t);

          ctx.save();
          ctx.translate(pos.x, pos.y);
          const dx = B.x - A.x;
          const dy = B.y - A.y;
          const ang = Math.atan2(dy, dx);
          ctx.rotate(ang);

          ctx.fillStyle = "#111827";
          ctx.strokeStyle = "#fdfdf6";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.rect(-10, -6, 20, 12);
          ctx.fill();
          ctx.stroke();

          ctx.fillStyle = "#fdfdf6";
          ctx.font = "9px system-ui";
          ctx.fillText(String(tr.passengers.length), -3, 3);

          ctx.restore();
        }
      }

      function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const rect = canvas.getBoundingClientRect();
        ctx.save();
        ctx.strokeStyle = "#e5e5dc";
        ctx.lineWidth = 1;
        const step = 40;
        for (let x = 0; x < rect.width; x += step) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, rect.height);
          ctx.stroke();
        }
        for (let y = 0; y < rect.height; y += step) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(rect.width, y);
          ctx.stroke();
        }
        ctx.restore();

        drawLines();

        for (const st of stations) {
          drawStationShape(st);
        }

        drawOverloadPie();
        drawPassengers();
        drawTrains();

        hudLines.textContent = lines.length;
        hudStations.textContent = stations.length;
        hudScore.textContent = score;
      }

      // ==== INPUT (LINES) ====
      function getMousePos(e) {
        const rect = canvas.getBoundingClientRect();
        return {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top,
        };
      }

      function findStationAt(pos, radius = 18) {
        for (const s of stations) {
          const dx = s.x - pos.x;
          const dy = s.y - pos.y;
          if (Math.sqrt(dx * dx + dy * dy) <= radius) return s;
        }
        return null;
      }

      canvas.addEventListener("mousedown", (e) => {
        if (gameOver) return;
        const pos = getMousePos(e);
        const s = findStationAt(pos);
        if (!s) return;

        draggingFromStation = s;
        currentLine = {
          color: lineColors[lines.length % lineColors.length],
          points: [{ x: s.x, y: s.y }],
          stationIds: [s.id],
        };
      });

      canvas.addEventListener("mousemove", (e) => {
        if (!currentLine) return;
        const pos = getMousePos(e);
        currentLine.points[currentLine.points.length - 1] = pos;
        render();
      });

      canvas.addEventListener("mouseup", (e) => {
        if (!currentLine || !draggingFromStation) {
          currentLine = null;
          draggingFromStation = null;
          return;
        }
        const pos = getMousePos(e);
        const target = findStationAt(pos);
        if (target && target.id !== draggingFromStation.id) {
          currentLine.points[currentLine.points.length - 1] = {
            x: target.x,
            y: target.y,
          };
          currentLine.stationIds.push(target.id);
          createLineFromStations(currentLine.stationIds);
        }
        currentLine = null;
        draggingFromStation = null;
        render();
      });

      canvas.addEventListener("mouseleave", () => {
        currentLine = null;
        draggingFromStation = null;
        render();
      });

      // ==== SIMULATION STEP ====
      let lastTimestamp = 0;

      function update(dt) {
        if (gameOver) return;

        const now = performance.now();

        // station spawn
        if (now - lastStationSpawn > STATION_SPAWN_INTERVAL) {
          if (stations.length < 6) {
            spawnStationNearCenter();
          } else {
            spawnStationFurtherOut();
          }
          lastStationSpawn = now;
        }

        // passenger spawn
        for (const st of stations) {
          if (now >= st.nextPassengerSpawn) {
            spawnPassengerAtStation(st);
            st.nextPassengerSpawn =
              now + randInRange(PASSENGER_SPAWN_MIN, PASSENGER_SPAWN_MAX);
          }
        }

        // train inventory growth
        if (now - lastTrainInventoryGain > TRAIN_INVENTORY_INTERVAL) {
          trainInventory += 1;
          lastTrainInventoryGain = now;
          updateTrainInventoryDisplay();
        }

        // overcrowding logic
        for (const st of stations) {
          let state = overloadState.get(st.id);
          const count = st.passengers.length;
          if (!state) {
            state = { timer: 0 };
            overloadState.set(st.id, state);
          }

          if (count >= OVERLOAD_THRESHOLD) {
            state.timer += dt;
            if (state.timer >= OVERLOAD_SECONDS) {
              losingStationId = st.id;
              triggerGameOver();
              break;
            }
          } else {
            if (state.timer > 0) {
              state.timer -= dt;
              if (state.timer < 0) state.timer = 0;
            }
          }
        }

        // trains
        for (const tr of trains) {
          const line = lines.find((l) => l.id === tr.lineId);
          if (!line) continue;
          const sts = lineStations(line);
          if (sts.length < 2) continue;

          const n = sts.length;
          let segIdx = tr.segmentIndex;
          let aIdx = segIdx;
          let bIdx = (segIdx + tr.direction + n) % n;
          let A = sts[aIdx];
          let B = sts[bIdx];

          if (tr.boardingTimer > 0) {
            tr.boardingTimer -= dt;
            if (tr.boardingTimer < 0) tr.boardingTimer = 0;
          } else {
            tr.t += tr.speed * dt;
            if (tr.t >= 1) {
              tr.t = 0;
              tr.segmentIndex = bIdx;
              aIdx = tr.segmentIndex;
              bIdx = (aIdx + tr.direction + n) % n;
              A = sts[aIdx];
              B = sts[bIdx];

              handleTrainAtStation(tr, line, sts[aIdx]);
            }
          }
        }
      }

      function handleTrainAtStation(tr, line, station) {
        // alight
        tr.passengers = tr.passengers.filter((p) => {
          const destStation = stations.find((st) => st.id === p.destStationId);
          if (destStation && destStation.id === station.id) {
            score += 1;
            return false;
          }
          return true;
        });

        const sts = lineStations(line);
        const currentIndex = sts.findIndex((st) => st.id === station.id);
        if (currentIndex === -1) return;

        const shapeDistances = computeShapeDistances(line, currentIndex);
        const chosenDir = tr.direction === 1 ? "forward" : "backward";

        const newBoarders = [];
        for (let i = 0; i < station.passengers.length; i++) {
          const p = station.passengers[i];
          const destShape = p.shape;
          const forwardDist = shapeDistances.forward[destShape];
          const backwardDist = shapeDistances.backward[destShape];

          if (forwardDist == null && backwardDist == null) continue;

          const bestDir =
            forwardDist == null
              ? "backward"
              : backwardDist == null
              ? "forward"
              : forwardDist <= backwardDist
              ? "forward"
              : "backward";

          if (
            bestDir === chosenDir &&
            tr.passengers.length + newBoarders.length < tr.capacity
          ) {
            const destId = findDestinationStationIdAlongLine(
              line,
              currentIndex,
              bestDir,
              destShape
            );
            if (destId != null) {
              newBoarders.push({ passenger: p, destStationId: destId });
            }
          }
        }

        if (newBoarders.length > 0) {
          for (const b of newBoarders) {
            const idx = station.passengers.indexOf(b.passenger);
            if (idx !== -1) station.passengers.splice(idx, 1);
            tr.passengers.push({
              shape: b.passenger.shape,
              destStationId: b.destStationId,
            });
            tr.boardingTimer += BOARDING_TIME_PER_PASSENGER;
          }
        }
      }

      function findDestinationStationIdAlongLine(
        line,
        startIndex,
        dirName,
        shape
      ) {
        const sts = lineStations(line);
        const n = sts.length;
        const step = dirName === "forward" ? 1 : -1;
        for (let k = 1; k < n; k++) {
          const idx = (startIndex + step * k + n) % n;
          if (sts[idx].shape === shape) return sts[idx].id;
        }
        return null;
      }

      function triggerGameOver() {
        if (gameOver) return;
        gameOver = true;
        gameOverOverlay.style.display = "flex";

        const now = performance.now();
        const seconds = Math.round((now - gameStartTime) / 1000);

        goScore.textContent = "Passengers delivered: " + score;
        goTime.textContent = "Time survived: " + seconds + "s";
        goLines.textContent = "Lines built: " + lines.length;
        goStations.textContent = "Stations spawned: " + stations.length;

        const st = losingStationId ? findStationById(losingStationId) : null;
        if (st) {
          goCause.textContent =
            "Overcrowded station: " + st.shape + " (" + st.id + ")";
        } else {
          goCause.textContent = "Overcrowded station triggered the loss.";
        }
      }

      // ==== MAIN LOOP ====
      function loop(timestamp) {
        const dt = (timestamp - lastTimestamp) / 1000;
        lastTimestamp = timestamp;

        update(dt);
        render();

        requestAnimationFrame(loop);
      }
    </script>
  </body>
</html>
